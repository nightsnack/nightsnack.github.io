---
title: 数据库隔离级别
date: 2018-03-21 17:47:30
tags: 
      - database
---

# 数据库隔离级别
<!-- more -->

|                  | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read uncommitted | √    | √          | √    |
| Read committed   | ×    | √          | √    |
| Repeatable read  | ×    | ×          | √    |
| Serializable     | ×    | ×          | ×    |

### Read Uncommitted

读未提交，脏读

>事物B开始——B修改数据（1000->2000）——B发现不对，回滚——B修改数据1000->1500——B提交
>
>​	事物A开始——A读到数据2000——结束									A再读发现不是2000



### Read committed    Oracle Sql Server

避免脏读但是不能避免**不可重复读**，

指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

>事物B开始——B访问数据得到2000————B休息了一会————B又访问发现不是2000——事物B提交错误
>
>​					   事物A开始——事物A转走了2000——事物A提交



### Repeatable read   MySQL

避免不可重复读，但是会出现**幻读**。

在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。**但这种方法却无法锁住insert的数据**，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免

> 事物A读 ——事物查询全部——事物A等了一会儿——事物A又查询，发现多了一条
>
> ​						事物B插入

​		

### Serializable

最高级别